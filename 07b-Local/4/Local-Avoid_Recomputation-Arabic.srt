1
00:00:06,000 --> 00:00:10,679
حتى الآن في هذه الدورة تجنبنا

2
00:00:08,240 --> 00:00:14,000
الحديث عن الأداء أو

3
00:00:10,679 --> 00:00:16,640
كفاءة البرنامج وقد فعلنا ذلك

4
00:00:14,000 --> 00:00:18,600
عمدًا والسبب هو أنه من

5
00:00:16,640 --> 00:00:20,920
السهل جدًا على المبرمجين القلق

6
00:00:18,600 --> 00:00:23,519
كثيرًا بشأن الكفاءة في وقت مبكر جدًا بشأن

7
00:00:20,920 --> 00:00:25,720
الكفاءة أو بصراحة القلق بشكل

8
00:00:23,519 --> 00:00:28,320
غير صحيح بشأن

9
00:00:25,720 --> 00:00:31,119
الكفاءة كقاعدة عامة من

10
00:00:28,320 --> 00:00:33,840
الأفضل تصميم برنامج بسيط

11
00:00:31,119 --> 00:00:35,719
يسهل فهمه وسهل

12
00:00:33,840 --> 00:00:38,079
التغيير ثم القلق بشأن

13
00:00:35,719 --> 00:00:40,520
الكفاءة لاحقًا بمجرد

14
00:00:38,079 --> 00:00:42,879
تشغيل البرنامج ما يمكنك فعله بعد ذلك هو

15
00:00:40,520 --> 00:00:46,079
تشغيل البرنامج على مجموعة بيانات عينة

16
00:00:42,879 --> 00:00:48,320
وقياس أدائه ومعرفة

17
00:00:46,079 --> 00:00:51,399
أين توجد مشاكل الأداء الحقيقية ما

18
00:00:48,320 --> 00:00:53,399
ستجده هو أنك غالبًا ما

19
00:00:51,399 --> 00:00:55,719
تتفاجأ ببعض الأشياء التي كنت تعتقد أنها ستكون مشكلة في

20
00:00:53,399 --> 00:00:57,359
الأداء يتم

21
00:00:55,719 --> 00:00:58,519
الاهتمام بها تلقائيًا بواسطة

22
00:00:57,359 --> 00:01:00,359


23
00:00:58,519 --> 00:01:01,480
تنفيذ لغة البرمجة أشياء أخرى ربما كنت

24
00:01:00,359 --> 00:01:04,479
تعتقد أنها ستكون

25
00:01:01,480 --> 00:01:06,000
مشكلة في الأداء اتضح أنها ليست كذلك ثم

26
00:01:04,479 --> 00:01:07,000
لسوء الحظ هناك بعض الأشياء الأخرى

27
00:01:06,000 --> 00:01:09,280
التي لم تعتقد أنها ستكون

28
00:01:07,000 --> 00:01:10,360
مشاكل في الأداء والتي تحولت إلى

29
00:01:09,280 --> 00:01:13,320


30
00:01:10,360 --> 00:01:15,320
مشاكل في الأداء قيل أن هناك فئة واحدة

31
00:01:13,320 --> 00:01:17,240
من مشاكل الأداء تحتاج حقًا إلى

32
00:01:15,320 --> 00:01:19,799
إصلاحها كجزء من

33
00:01:17,240 --> 00:01:22,200
التصميم والتي لها علاقة بمشاكل

34
00:01:19,799 --> 00:01:24,079
النمو الأسي في الوقت الذي يستغرقه

35
00:01:22,200 --> 00:01:26,320
برنامجك للتشغيل مع

36
00:01:24,079 --> 00:01:27,880
تزايد حجم البيانات  النمو الأسي الصحيح

37
00:01:26,320 --> 00:01:30,520
والأداء لن يكونا

38
00:01:27,880 --> 00:01:32,439
خاصية جيدة لبرنامجك،

39
00:01:30,520 --> 00:01:34,799
لذا ما سنفعله في هذا الفيديو

40
00:01:32,439 --> 00:01:38,079
هو إلقاء نظرة على كيفية استخدام local للتعامل

41
00:01:34,799 --> 00:01:40,520
مع فئة مهمة من هذه

42
00:01:38,079 --> 00:01:42,840
المشكلات، لقد عدت إلى إصدار من

43
00:01:40,520 --> 00:01:45,200
برنامج نظام الملفات fsv

44
00:01:42,840 --> 00:01:47,560
6 وفي هذا الإصدار تكون

45
00:01:45,200 --> 00:01:50,159
تعريفات البيانات هي نفسها، ولدي هذه

46
00:01:47,560 --> 00:01:52,240
الوظيفة Mak skinny وما يجعل

47
00:01:50,159 --> 00:01:54,960
skinny يفعله هو أنه يجعل الأشجار

48
00:01:52,240 --> 00:01:57,159
نحيفة للغاية وليست كثيفة على الإطلاق،

49
00:01:54,960 --> 00:02:00,079
كل عنصر لديه طفل واحد فقط حتى

50
00:01:57,159 --> 00:02:03,200
يصل إلى الورقة، وإذا قلت

51
00:02:00,079 --> 00:02:05,119
Guinea of two على سبيل المثال، أحصل على شجرة

52
00:02:03,200 --> 00:02:07,479
تبدو هكذا يوجد عنصر

53
00:02:05,119 --> 00:02:10,560
يسمى X في الأعلى، وله طفل واحد يسمى X

54
00:02:07,479 --> 00:02:14,480
وله طفل واحد يسمى Y

55
00:02:10,560 --> 00:02:17,480
وهو الورقة، لذا فهو xxxxx ثم

56
00:02:14,480 --> 00:02:20,280
Y في الأسفل، لذا يجعل skinny من 10 هو

57
00:02:17,480 --> 00:02:23,959
10 x's و y يجعل skinny من 100 هو

58
00:02:20,280 --> 00:02:26,840
100 x's و y هذا كل ما يجعل skinny

59
00:02:23,959 --> 00:02:30,680
يفعله، ثم find هي الوظيفة التي

60
00:02:26,840 --> 00:02:33,000
صممناها من قبل والتي تحاول فقط العثور على

61
00:02:30,680 --> 00:02:36,400
عنصر ذي قيمة معينة

62
00:02:33,000 --> 00:02:40,360
الاسم لذا ما سأفعله الآن هو أنني

63
00:02:36,400 --> 00:02:44,360
سأستدعي العثور على Y على بعض الأشجار ذات

64
00:02:40,360 --> 00:02:47,040
الأعماق المختلفة وأنا أستخدم بدائية BSL جديدة

65
00:02:44,360 --> 00:02:49,760
هنا إنه شيء خاص جدًا

66
00:02:47,040 --> 00:02:51,840
إنه أشبه بـ if أكثر من الدالة لأنه

67
00:02:49,760 --> 00:02:55,560
يقيم متغيره

68
00:02:51,840 --> 00:02:58,000
بطريقة خاصة ولكن ما يفعله الوقت هو أنه

69
00:02:55,560 --> 00:03:01,599
يقيم نهايته العليا ويرى كم من الوقت

70
00:02:58,000 --> 00:03:03,400
يستغرق ويعيد لنا الوقت لذا ما

71
00:03:01,599 --> 00:03:06,599
يمكنك رؤيته هنا هو أنني أقوم بتوقيت المدة التي

72
00:03:03,400 --> 00:03:12,599
يستغرقها العثور على Y في شجرة 10 عمق

73
00:03:06,599 --> 00:03:16,560
شجرة 11 عمق 12 13 14 وهكذا حسنًا، لذا

74
00:03:12,599 --> 00:03:17,879
ها نحن ذا إذا قمت بتشغيل ذلك فإن الأوقات التي

75
00:03:16,560 --> 00:03:21,040
أحصل عليها دعني

76
00:03:17,879 --> 00:03:23,519
أنتقل إلى الجزء العلوي حتى تتمكن من

77
00:03:21,040 --> 00:03:25,280
رؤية الوقت الذي يستغرقه في شجرة وهو

78
00:03:23,519 --> 00:03:28,599
10 لذا فإن Y هو

79
00:03:25,280 --> 00:03:30,599
الحادي عشر وهو 2 مللي ثانية وهذا بالمللي

80
00:03:28,599 --> 00:03:33,599
ثانية

81
00:03:30,599 --> 00:03:38,040
في المرة التالية يكون 3 مللي ثانية والمرة

82
00:03:33,599 --> 00:03:40,680
التالية يكون 7 ثم يكون 20 35

83
00:03:38,040 --> 00:03:43,959
57 لذا ما سأفعله الآن هو رسم بياني

84
00:03:40,680 --> 00:03:47,280
لذلك دعونا نلقي نظرة على  هذه

85
00:03:43,959 --> 00:03:52,879
المؤامرة شيء سيء يحدث هنا أليس

86
00:03:47,280 --> 00:03:55,159
كذلك في كل مرة نجعل فيها الشجرة

87
00:03:52,879 --> 00:03:56,519
أعمق ما الذي يحدث للوقت الذي يستغرقه

88
00:03:55,159 --> 00:04:00,879
هذا

89
00:03:56,519 --> 00:04:02,959
للتشغيل إنه يتزايد بما

90
00:04:00,879 --> 00:04:05,760
يزيد بمقدار قريب جدًا من

91
00:04:02,959 --> 00:04:08,239
عامل اثنين دعني أضيف بضعة أشياء

92
00:04:05,760 --> 00:04:08,239
أخرى لأرى أننا

93
00:04:08,720 --> 00:04:14,319
سنجعل ذلك 16 و

94
00:04:17,320 --> 00:04:23,160
17 إذا قمنا بتوسيع المؤامرة

95
00:04:20,840 --> 00:04:24,560
تغيرت الأرقام قليلاً حسنًا

96
00:04:23,160 --> 00:04:25,880
تغيرت الأرقام قليلاً وذلك

97
00:04:24,560 --> 00:04:28,000
لأنها لا تحسب دائمًا

98
00:04:25,880 --> 00:04:29,960
نفس الوقت بالضبط اتضح أن

99
00:04:28,000 --> 00:04:33,479
قياس المدة التي يستغرقها برنامج T

100
00:04:29,960 --> 00:04:35,199
للتشغيل هو أمر معقد للغاية ولكن

101
00:04:33,479 --> 00:04:37,759
هذه الأرقام هي

102
00:04:35,199 --> 00:04:41,479
مؤشر جيد على المدة التي يستغرقها التشغيل

103
00:04:37,759 --> 00:04:41,479
لذا مع هذا

104
00:04:41,639 --> 00:04:48,440
الرسم البياني الموسع الآن قم بالتمرير قليلاً حتى نتمكن من رؤية جميع

105
00:04:44,240 --> 00:04:51,120
البيانات من الواضح حقًا أنه يبدو أنه

106
00:04:48,440 --> 00:04:53,800
يستغرق ضعف الوقت للتشغيل

107
00:04:51,120 --> 00:04:57,520
عندما نجعل الشجرة

108
00:04:53,800 --> 00:05:00,960
أعمق الآن هذه

109
00:04:57,520 --> 00:05:02,960
مشكلة أداء خطيرة تصبح الشجرة أعمق بمقدار واحد جيد

110
00:05:00,960 --> 00:05:06,560
يستغرق ضعف الوقت هذه مشكلة أداء أسيّة

111
00:05:02,960 --> 00:05:08,639
حسنًا لأنه

112
00:05:06,560 --> 00:05:11,759
كلما أصبحت الشجرة أعمق وأعمق فهي في

113
00:05:08,639 --> 00:05:15,880
الأساس اثنان إلى عمق الشجرة

114
00:05:11,759 --> 00:05:18,080
وهذا سيء فلماذا

115
00:05:15,880 --> 00:05:20,479
يحدث ذلك حسنًا إليك  لماذا يحدث هذا

116
00:05:18,080 --> 00:05:24,680
هنا في

117
00:05:20,479 --> 00:05:27,960
find انظر ماذا يفعل fine هنا يقول

118
00:05:24,680 --> 00:05:29,759
حسنًا اذهب وابحث عن n في الطفل الأول

119
00:05:27,960 --> 00:05:32,880
وإذا لم ينتج عنه false

120
00:05:29,759 --> 00:05:34,960
فهذه هي القيمة التي تريدها لذا أنتج

121
00:05:32,880 --> 00:05:37,479
تلك

122
00:05:34,960 --> 00:05:39,400
القيمة ومن منظور

123
00:05:37,479 --> 00:05:42,840
إنتاج القيمة الصحيحة هذا البرنامج

124
00:05:39,400 --> 00:05:42,840
صحيح تمامًا وجيد

125
00:05:42,880 --> 00:05:47,840
ورائع ولكن المشكلة التي يواجهها هي أنه

126
00:05:45,840 --> 00:05:48,880
في الفرع حيث يجد القيمة التي

127
00:05:47,840 --> 00:05:52,800
يبحث

128
00:05:48,880 --> 00:05:56,360
عنها فإنه يبحث في ذلك الفرع

129
00:05:52,800 --> 00:05:59,080
مرتين لذا في هذه الحالة المتدهورة الخاصة

130
00:05:56,360 --> 00:06:00,960
للشجرة حيث تكون الشجرة فرعًا واحدًا

131
00:05:59,080 --> 00:06:04,800
طويلًا أولًا

132
00:06:00,960 --> 00:06:06,880
في الأعلى نبحث في

133
00:06:04,800 --> 00:06:10,840
المستوى التالي لأسفل

134
00:06:06,880 --> 00:06:12,960
مرتين ثم لكل منها

135
00:06:10,840 --> 00:06:16,400
نبحث في المستوى التالي لأسفل

136
00:06:12,960 --> 00:06:18,880
مرتين لأنه في كل مرة نفعل هذا أولاً

137
00:06:16,400 --> 00:06:20,360
لمعرفة ما إذا كان موجودًا وعندما نكتشف أنه موجود نبحث

138
00:06:20,360 --> 00:06:28,039
عنه مرة أخرى لإنتاج

139
00:06:23,479 --> 00:06:30,360
النتيجة لذلك نبحث في هذا المستوى مرتين

140
00:06:28,039 --> 00:06:33,840
نبحث في هذا المستوى أربع مرات

141
00:06:30,360 --> 00:06:36,680
اثنان * اثنان في كل مرة يكون أكثر بمرتين

142
00:06:33,840 --> 00:06:38,360
وهناك نمو أسي لذا

143
00:06:36,680 --> 00:06:40,440
هناك يوجد

144
00:06:38,360 --> 00:06:43,680
نمو أسي يمكننا أن نرى

145
00:06:40,440 --> 00:06:46,120
لماذا هو عامل اثنين في كل

146
00:06:43,680 --> 00:06:48,560
مرة لذا كيف نصلح

147
00:06:46,120 --> 00:06:50,319
ذلك جيدًا إنه من السهل حقًا إصلاح ذلك

148
00:06:48,560 --> 00:06:52,880
باستخدام local local

149
00:06:50,319 --> 00:06:56,680
هو بالضبط ما لدينا  أريد أن

150
00:06:52,880 --> 00:06:57,800
أستخدم هنا بشكل أساسي، نحن نستدعي

151
00:06:56,680 --> 00:07:00,440
دالة

152
00:06:57,800 --> 00:07:04,080
هنا ثم نستدعيها هنا

153
00:07:00,440 --> 00:07:06,520
مرة أخرى لإعادة حساب نفس

154
00:07:04,080 --> 00:07:09,000
القيمة وما يمكننا فعله هو أنه يمكننا استخدام

155
00:07:06,520 --> 00:07:11,599
local لتجنب إعادة حساب نفس

156
00:07:09,000 --> 00:07:14,520
القيمة الآن شاهد هنا

157
00:07:11,599 --> 00:07:17,560
الطريقة المنهجية التي أفعل بها ذلك أجد

158
00:07:14,520 --> 00:07:21,120
تعبيرًا مضمنًا يحتوي على كلا

159
00:07:17,560 --> 00:07:22,840
الحسابين لذا إليك واحدًا وهنا

160
00:07:21,120 --> 00:07:25,160
آخر وأجد أقرب

161
00:07:22,840 --> 00:07:27,400
تعبير مضمن يقوم بذلك في

162
00:07:25,160 --> 00:07:31,520
هذه الحالة يكون هذا

163
00:07:27,400 --> 00:07:31,520
إذا قمت بتغليف ذلك في local

164
00:07:32,280 --> 00:07:38,080
وأعطيت أقول Define وأنت تعلم أنه يجب أن

165
00:07:35,039 --> 00:07:41,160
أفكر في بعض الأسماء هنا،

166
00:07:38,080 --> 00:07:43,120
أليس كذلك؟ يمكنني تسميتها

167
00:07:41,160 --> 00:07:47,800
try

168
00:07:43,120 --> 00:07:53,000
وأخذ هذه القيمة هنا هذا

169
00:07:47,800 --> 00:07:55,280
التعبير وأطلق اسم try على نتيجته لذا

170
00:07:53,000 --> 00:07:58,240
الآن أقول مهلاً، افعل هذا جيدًا

171
00:07:55,280 --> 00:08:00,000
ودعنا نسميها try ثم في كل مكان

172
00:07:58,240 --> 00:08:02,440
اعتدت أن يكون لدي التعبير

173
00:08:00,000 --> 00:08:02,440
أضع

174
00:08:04,039 --> 00:08:10,680
try وأحتاج إلى إغلاق هذا local لذا سيكون

175
00:08:07,720 --> 00:08:13,080
ذلك موجودًا هناك إذا

176
00:08:10,680 --> 00:08:14,960
أضفت قلمًا آخر، فأنا أقوم بأمر ey

177
00:08:13,080 --> 00:08:17,000
لإصلاح

178
00:08:14,960 --> 00:08:20,599
المسافة البادئة والآن ما يقوله هذا هو أنه

179
00:08:17,000 --> 00:08:24,319
يقول مهلاً، اذهب وابحث في الطفل الأول

180
00:08:20,599 --> 00:08:27,759
ودعنا نسمي النتيجة التي نحصل عليها من ذلك

181
00:08:24,319 --> 00:08:29,639
try والآن  يمكنني النظر إلى القيمة try

182
00:08:27,759 --> 00:08:32,240
عدة مرات كما أريد في هذه الحالة

183
00:08:29,639 --> 00:08:36,000
ربما مرتين دون إعادة حساب

184
00:08:32,240 --> 00:08:38,919
القيمة لقد حسبتها مرة واحدة فقط هنا

185
00:08:36,000 --> 00:08:40,279
أسميها try ثم في كل مرة أستخدم try

186
00:08:38,919 --> 00:08:43,000
لا أعيد حسابها

187
00:08:40,279 --> 00:08:46,360
لذا إذا جربنا هذا الإصدار من

188
00:08:43,000 --> 00:08:47,880
البرنامج هاه آسف سامحوني على التورية إذا قمنا

189
00:08:46,360 --> 00:08:49,519
بتشغيل هذا الإصدار من البرنامج ونظرنا

190
00:08:47,880 --> 00:08:51,080
إلى أرقام الأداء التي نحصل عليها

191
00:08:49,519 --> 00:08:54,360


192
00:08:51,080 --> 00:08:56,680
لا نرى

193
00:08:54,360 --> 00:08:59,640
نموًا أسيًا لذا فهذه حالة نستخدم فيها

194
00:08:56,680 --> 00:09:03,079
local لتجنب إعادة الحساب الآن

195
00:08:59,640 --> 00:09:05,519
أريد أن أكون واضحًا حقًا هنا سبب

196
00:09:03,079 --> 00:09:09,279
أهمية إعادة الحساب هذه لأنها

197
00:09:05,519 --> 00:09:12,519
متكررة تؤدي إعادة الحساب هذه

198
00:09:09,279 --> 00:09:14,360
إلى نمو أسي بسبب

199
00:09:12,519 --> 00:09:17,440
التكرار إليك شيء

200
00:09:14,360 --> 00:09:20,079
أشجعك على عدم القيام به إذا كنت على

201
00:09:17,440 --> 00:09:22,760
سبيل المثال ستأخذ وسيطة

202
00:09:20,079 --> 00:09:26,440
تستهلكها وتضيف واحدة إليها

203
00:09:22,760 --> 00:09:28,760
وتستخدمها مرتين كما تعلم فإن استخدام local

204
00:09:26,440 --> 00:09:31,399
لتجنب حساب إضافة واحد

205
00:09:28,760 --> 00:09:34,160
مرتين لا يستحق القيام به سيجعل

206
00:09:31,399 --> 00:09:36,240
برنامجك أصعب في القراءة مقابل

207
00:09:34,160 --> 00:09:38,800
القليل وربما لأكون صادقًا معك

208
00:09:36,240 --> 00:09:40,839
لا يوجد أي مكسب في الأداء على

209
00:09:38,800 --> 00:09:42,680
الإطلاق لأن تطبيقات لغات البرمجة

210
00:09:40,839 --> 00:09:44,920
جيدة في اكتشاف

211
00:09:42,680 --> 00:09:49,640
أشياء مثل هذه والقيام بها  بالنسبة

212
00:09:44,920 --> 00:09:52,399
لك ولكن هنا لأن لدينا

213
00:09:49,640 --> 00:09:55,160
دالة متكررة إذا قمنا بإعادة الحساب في

214
00:09:52,399 --> 00:09:57,480
كل مستوى نحصل على النمو الأسي

215
00:09:55,160 --> 00:09:59,040
مشاكل الأداء الأسي

216
00:09:57,480 --> 00:10:01,720
سيئة بالتأكيد لا أحد سيقول أبدًا

217
00:09:59,040 --> 00:10:04,839
أن هذه ليست مشكلة لذا فإن

218
00:10:01,720 --> 00:10:06,880
الأمر يستحق هنا استخدام local لتجنب

219
00:10:04,839 --> 00:10:09,560
إعادة الحساب لذا فهذا هو

220
00:10:06,880 --> 00:10:12,399
استخدامنا الثاني المهم لـ local نستخدمه

221
00:10:09,560 --> 00:10:14,079
لتجنب إعادة حساب القيم خاصة

222
00:10:12,399 --> 00:10:16,120
في الدوال المتكررة لأنه في هذه

223
00:10:14,079 --> 00:10:19,040
الدوال المتكررة

224
00:10:16,120 --> 00:10:20,200
يمكن أن يؤدي إعادة الحساب إلى

225
00:10:19,040 --> 00:10:23,560


226
00:10:20,200 --> 00:10:25,839
مشاكل في الأداء الأسي وإعادة الهيكلة العامة هي

227
00:10:23,560 --> 00:10:29,800
أنك تجد أقرب تعبير

228
00:10:25,839 --> 00:10:32,880
يحيط بجميع القيم المعاد حسابها تقوم

229
00:10:29,800 --> 00:10:35,240
بلف local حول هذا

230
00:10:32,880 --> 00:10:37,519
التعبير تعطي القيمة بعض الأسماء

231
00:10:35,240 --> 00:10:40,440
مثل try أو شيء آخر ثم

232
00:10:37,519 --> 00:10:42,839
تستخدم هذا الاسم بدلاً من كل

233
00:10:40,440 --> 00:10:45,839
تعبير أصلي أعادت حساب

234
00:10:42,839 --> 00:10:45,839
القيمة